/*
 * Copyright (C) 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.ftcresearch.tfod.generators;

import android.app.Activity;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.support.annotation.NonNull;
import android.util.Log;

import com.google.ftcresearch.tfod.util.Rate;
import com.google.ftcresearch.tfod.util.Timer;
import com.google.ftcresearch.tfod.util.YuvRgbFrame;
import com.google.ftcresearch.tfod.util.Size;

import java.nio.IntBuffer;
import java.util.concurrent.TimeUnit;

/**
 * Implements {@link FrameGenerator} by returning a constantly moving section of the input frame.
 *
 * <p>The output frame is generated by considering a point which is rotating about the true center
 * of the input image at a specified radius. This point is then treated as the center for a
 * rectangle, and the biggest rectangle which will fit within the image while maintaining this
 * center is found. This rectangular portion of the original bitmap is resized and returned as the
 * next frame in the sequence.
 */
public class MovingImageFrameGenerator implements FrameGenerator {
  private static final String TAG = "MovingFrameGenerator";

  private static final double FRAME_RATE = 30; // Hz

  private static final double FRAME_PERIOD = 2; // second
  private static final double ROTATION_RADIUS_RATIO = 0.1;
  private final double widthRadius;
  private final double heightRadius;

  private final Bitmap bm;
  private long frameCount = 0;

  private final Timer timer = new Timer(TAG);
  private final Rate rate = new Rate(10);

  /** @param bm Bitmap to use as the source. */
  public MovingImageFrameGenerator(@NonNull Bitmap bm) {
    this.bm = bm;

    widthRadius = this.bm.getWidth() * ROTATION_RADIUS_RATIO;
    heightRadius = this.bm.getHeight() * ROTATION_RADIUS_RATIO;

    Log.d(
        TAG,
        "Created new ImageFrameGenerator with an image: "
            + this.bm.getWidth()
            + ","
            + this.bm.getHeight());
  }

  @Override
  @NonNull public YuvRgbFrame getFrame() throws InterruptedException {

    // Determine how much to translate the center point of the original image, based on the
    // amount of time that has elapsed since the last frame. This is essentially just moving a
    // point along an ellipse whose center is at the true center of the original image.
    double timeElapsed = frameCount / FRAME_RATE;
    double periodPercent = (timeElapsed % FRAME_PERIOD) / FRAME_PERIOD;
    double periodRadians = periodPercent * (2 * Math.PI);
    double widthOffset = Math.cos(periodRadians) * widthRadius;
    double heightOffset = Math.sin(periodRadians) * heightRadius;

    // Figure out where the center of the output rectangle will be
    double centerX = bm.getWidth() / 2 + widthOffset;
    double centerY = bm.getHeight() / 2 + heightOffset;

    // Figure out how big of a rectangle we can make around the new center point.
    double newSizeRatio = 1.0 - 2 * ROTATION_RADIUS_RATIO;
    double newWidth = bm.getWidth() * newSizeRatio;
    double newHeight = bm.getHeight() * newSizeRatio;

    // Find the left / top coordinates of the new rectangle.
    double left = (centerX - newWidth / 2);
    double top = (centerY - newHeight / 2);

    timer.start("Creating bitmap + frame");
    // Make a new Bitmap that's been translated a little
    timer.start("Just creating bitmap");
    Bitmap newBm = Bitmap.createBitmap(bm, (int) left, (int) top, (int) newWidth, (int) newHeight);
    timer.end();
    Bitmap newBmScaled = Bitmap.createScaledBitmap(newBm, bm.getWidth(), bm.getHeight(), true);

    IntBuffer rgbFrame = IntBuffer.allocate(newBmScaled.getWidth() * newBmScaled.getHeight());
    newBmScaled.copyPixelsToBuffer(rgbFrame);

    YuvRgbFrame frame = new YuvRgbFrame(rgbFrame, new Size(newBmScaled.getWidth(),
        newBmScaled.getHeight()));
    timer.end();

    frameCount++;

    rate.checkedSleep();
    return frame;
  }

  @Override
  public void shutdown(Activity activity) {
  }

  public static MovingImageFrameGenerator makeFromResourceId(Context context, int resourceId) {
    final Bitmap bm = BitmapFactory.decodeResource(context.getResources(), resourceId);
    final Bitmap bmScaled = Bitmap.createScaledBitmap(bm, 1920, 1080, true);
    return new MovingImageFrameGenerator(bmScaled);
  }
}